%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
%          Generated by MATLAB 9.13 and Fixed-Point Designer 7.5           %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MATLAB design: Symmetric FIR Filter
% 
% Introduction:
%
% We can reduce the complexity of the FIR filter by leveraging its symmetry. 
% Symmetry for an n-tap filter implies, coefficient h0 = coefficient hn-1, 
% coefficient, h1 = coefficient hn-2, etc. In this case, the number of 
% multipliers can be approximately halved. The key is to add the 
% two data values that need to be multiplied with the same coefficient 
% prior to performing the multiplication. 
%
% Key Design pattern covered in this example: 
% (1) Filter states represented using the persistent variables
% (2) Filter coefficients passed in as parameters
%   Copyright 2011-2019 The MathWorks, Inc.
%#codegen
function [y_out, delayed_xout] = mlhdlc_sfir_fixpt(x_in,h_in1,h_in2,h_in3,h_in4)   
% Symmetric FIR Filter

% declare and initialize the delay registers
fm = get_fimath();

persistent ud1 ud2 ud3 ud4 ud5 ud6 ud7 ud8;
if isempty(ud1)
    ud1 = fi(0, 1, 14, 12, fm); ud2 = fi(0, 1, 14, 12, fm); ud3 = fi(0, 1, 14, 12, fm); ud4 = fi(0, 1, 14, 12, fm); ud5 = fi(0, 1, 14, 12, fm); ud6 = fi(0, 1, 14, 12, fm); ud7 = fi(0, 1, 14, 12, fm); ud8 = fi(0, 1, 14, 12, fm);
end

% access the previous value of states/registers
a1 = fi(ud1 + ud8, 1, 14, 12, fm); a2 = fi(ud2 + ud7, 1, 14, 12, fm);
a3 = fi(ud3 + ud6, 1, 14, 12, fm); a4 = fi(ud4 + ud5, 1, 14, 11, fm);

% multiplier chain
m1 = fi(h_in1 * a1, 1, 14, 14, fm); m2 = fi(h_in2 * a2, 1, 14, 15, fm);
m3 = fi(h_in3 * a3, 1, 14, 14, fm); m4 = fi(h_in4 * a4, 1, 14, 13, fm);

% adder chain
a5 = fi(m1 + m2, 1, 14, 14, fm); a6 = fi(m3 + m4, 1, 14, 12, fm);

% filtered output
y_out = fi(a5 + a6, 1, 14, 12, fm);

% delayout input signal
delayed_xout = fi(ud8, 1, 14, 12, fm);

% update the delay line
ud8(:) = ud7; 
ud7(:) = ud6;
ud6(:) = ud5;
ud5(:) = ud4;
ud4(:) = ud3;
ud3(:) = ud2;
ud2(:) = ud1;
ud1(:) = x_in;
end


function fm = get_fimath()
	fm = fimath('RoundingMethod', 'Floor',...
	     'OverflowAction', 'Wrap',...
	     'ProductMode','FullPrecision',...
	     'MaxProductWordLength', 128,...
	     'SumMode','FullPrecision',...
	     'MaxSumWordLength', 128);
end
